"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = void 0;
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const fs_1 = require("fs");
const LanguageID = 'php';
const INDEXING_STARTED_NOTIFICATION = new vscode_languageserver_protocol_1.NotificationType('indexingStarted');
const INDEXING_ENDED_NOTIFICATION = new vscode_languageserver_protocol_1.NotificationType('indexingEnded');
const INDEX_WORKSPACE_REQUEST = new vscode_languageserver_protocol_1.RequestType('indexWorkspace');
const CANCEL_INDEXING_REQUEST = new vscode_languageserver_protocol_1.RequestType('cancelIndexing');
let languageClient;
let extensionContext;
let clientDisposable;
let file;
let licenceKey;
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        extensionContext = context;
        let c = coc_nvim_1.workspace.getConfiguration();
        const config = c.get("phpls");
        const intelephenseConfig = c.get("intelephense");
        const enable = config.enable;
        licenceKey = intelephenseConfig.licenceKey || '';
        if (enable === false)
            return;
        if (fs_1.existsSync(config.path)) {
            try {
                file = require.resolve(config.path);
                if (file.endsWith("intelephense.js") === false)
                    throw new Error();
                /* ---- See :CocOpenLog ---- */
                extensionContext.logger.info("intelephense module (phpls.path) is ready to be started");
            }
            catch (e) {
                coc_nvim_1.workspace.showMessage("intelephense module not found! phpls.path is invalid.", "error");
                return;
            }
        }
        else {
            try {
                file = require.resolve("intelephense");
                if (file.endsWith("intelephense.js") === false)
                    throw new Error();
                /* ---- See :CocOpenLog ---- */
                extensionContext.logger.info("intelephense module (builtin) is ready to be started");
            }
            catch (e) {
                coc_nvim_1.workspace.showMessage("intelephense module not found! builtin module is invalid", "error");
                return;
            }
        }
        languageClient = createClient(context, false);
        let indexWorkspaceDisposable = coc_nvim_1.commands.registerCommand('intelephense.index.workspace', indexWorkspace);
        let cancelIndexingDisposable = coc_nvim_1.commands.registerCommand('intelephense.cancel.indexing', cancelIndexing);
        context.subscriptions.push(indexWorkspaceDisposable, cancelIndexingDisposable);
        clientDisposable = languageClient.start();
    });
}
exports.activate = activate;
function fixItem(item) {
    if (/^\\\w+/.test(item.insertText) && !/^(\\\w+){2,}/.test(item.insertText)) {
        item.insertText = item.insertText.replace('\\', '');
    }
}
function createClient(context, clearCache) {
    // The debug options for the server
    let debugOptions = {
        execArgv: ["--nolazy", "--inspect=6039", "--trace-warnings", "--preserve-symlinks"],
        detached: true
    };
    let serverOptions = {
        run: { module: file, transport: coc_nvim_1.TransportKind.ipc },
        debug: { module: file, transport: coc_nvim_1.TransportKind.ipc, options: debugOptions }
    };
    // todo: implements createMiddleware method
    // let middleware = createMiddleware(() => {
    // 	return languageClient;
    // });
    let clientOptions = {
        documentSelector: [
            { language: LanguageID, scheme: 'file' },
            { language: LanguageID, scheme: 'untitled' }
        ],
        initializationOptions: {
            globalStoragePath: context.storagePath,
            storagePath: context.storagePath,
            clearCache: clearCache,
            licenceKey: licenceKey,
        },
        middleware: {
            provideCompletionItem: (document, position, context, token, next) => {
                return Promise.resolve(next(document, position, context, token)).then((res) => {
                    let doc = coc_nvim_1.workspace.getDocument(document.uri);
                    if (!doc)
                        return [];
                    if (res.hasOwnProperty('isIncomplete')) {
                        let itemList = res;
                        if (Array.isArray(itemList.items)) {
                            itemList.items.forEach(fixItem);
                        }
                        return itemList;
                    }
                    let items = res;
                    if (Array.isArray(items)) {
                        items.forEach(fixItem);
                    }
                    return items;
                });
            }
        },
    };
    languageClient = new coc_nvim_1.LanguageClient("phpls", "PHP Language Server", serverOptions, clientOptions);
    languageClient.onReady().then(() => {
        let startedTime;
        languageClient.onNotification(INDEXING_STARTED_NOTIFICATION.method, () => {
            startedTime = new Date();
            coc_nvim_1.workspace.showMessage('intelephense indexing ...');
        });
        languageClient.onNotification(INDEXING_ENDED_NOTIFICATION.method, () => {
            let usedTime = Math.abs(new Date().getTime() - startedTime.getTime());
            coc_nvim_1.workspace.showMessage("Indexed php files, times: " + usedTime + "ms");
        });
    });
    return languageClient;
}
function indexWorkspace(licenceKey) {
    if (!languageClient) {
        return;
    }
    languageClient.stop().then(_ => {
        clientDisposable.dispose();
        languageClient = createClient(extensionContext, true);
        clientDisposable = languageClient.start();
    });
}
function cancelIndexing() {
    languageClient.sendRequest(CANCEL_INDEXING_REQUEST.method);
}
//# sourceMappingURL=index.js.map